#include <stdlib.h> //Para usar system("cls");
#include <conio.h> //Para usar getch();

//#include "ListaPosicionada_Arreglo.h"
#include "ListaPosicionada_LSE.h"
//#include "ListaPosicionada_LDE.h"

//#include "ListaIndexada_Arreglo.h"
#include "ListaIndexada_LSE.h"

#include "ListaOrdenada_Arreglo.h"
//#include "ListaOrdenada_LSE.h"
/*

/*
@Efecto: Busca en la lista el elemento recibido como parametro y devuelve si existe o no
@Requiere: Una lista no vacia y un elemento valido(de tipo) en la lista
@Modifica: Este metodo no modifica nada
*/
bool buscar(ListaInd& lista, int elemento){
	bool existe = false;
	int actual = 0;
	int cantElem = lista.numElem();
	while (!existe && actual < cantElem){
		if( lista.recuperar(actual) == elemento ){
			existe = true;
		}
		++actual;
	}
	return existe;
}


/*
@Efecto: Invierte todos los elementos de una lista, de manera en que el ultimo sea el primero y el primero el ultimo y asi respectivamente
@Requiere: Una lista no vacia y de tamano minimo de dos
@Modifica: Este metodo modifica la lista
*/
void invertir(ListaInd& lista){
	int indI = 0;
	int indF = lista.numElem()-1;
	while(indI != indF && indI+1 != indF ){
		lista.intercambiar(indI,indF);
		++indI;
		--indF;
	}
	lista.intercambiar(indI,indF);
}

/*
@Efecto: Averigua si una lista es simetrica verfificando si la primera es igual a la ultima y asi sucesivamente
@Requiere: Una lista no vacia y de tamano minimo de dos
@Modifica: Este metodo modifica la lista
*/
bool simetrica(ListaInd& lista){
	int indI = 0;
	int indF = lista.numElem() - 1;
	bool esSimetrica = true;
	if(lista.numElem() > 1){	
		while(esSimetrica && indI != indF && indI+1 != indF){
			if(lista.recuperar(indI) != lista.recuperar(indF)){
				esSimetrica = false;
			}
			++indI;
			--indF;
		}
		if (lista.recuperar(indI) != lista.recuperar(indF)) {
			esSimetrica = false;
		}
	}
	return esSimetrica;
}

/*
@Efecto: Ordena los elementos de la lista en orden ascendente y se manera secuencial iterativa mediante...
@Requiere: Una lista no vacia y de tamano minimo de dos
@Modifica: Este metodo modifica la lista
*/
void seleccionIterativo(ListaInd& lista) {
	int minimo = 0;
		for (int i = 0; i < lista.numElem() - 1; ++i) {
			minimo = i;
			for (int j = i + 1; j < lista.numElem(); ++j) {
				if (lista.recuperar(j) < lista.recuperar(minimo)) {
					minimo = j;
				}
			}
			lista.intercambiar(i, minimo);
		}
}

/*
@Efecto: 
@Requiere: Una lista no vacia y de tamano minimo de dos
@Modifica: Este metodo modifica la lista
*/
void seleccionRecursivo(ListaInd& lista, int inicio) {
	if (inicio == lista.numElem() - 1) {
		return;
	}
	else {
		int minimo = inicio;
		for (int i = inicio + 1; i < lista.numElem(); ++i) {
			if (lista.recuperar(i) < lista.recuperar(minimo)) {
				minimo = i;
			}
		}
		lista.intercambiar(inicio, minimo);
		seleccionRecursivo(lista, ++inicio);
	}
}

/*
@Efecto: 
@Requiere: Una lista no vacia y de tamano minimo de dos
@Modifica: Este metodo modifica la lista
*/
void burbujaOriginal(ListaInd& lista) {
	for (int i = 0; i < lista.numElem() - 1; ++i) {
		for (int j = 0; j < lista.numElem() - i - 1; ++j) {
			if (lista.recuperar(j) > lista.recuperar(j + 1)) {
				lista.intercambiar(j + 1, j);
			}
		}
	}
}

/*
@Efecto: 
@Requiere: Una lista no vacia y de tamano minimo de dos
@Modifica: Este metodo modifica la lista
*/
void eliminarRepetidos(ListaInd& lista){
	for(int i = 0; i < lista.numElem(); ++i){
		bool repetido = false;
		for(int j = 0; j < lista.numElem(); ++j){
			if(i != j && lista.recuperar(i) == lista.recuperar(j) ){
				repetido = true;
				j = lista.numElem();
			}
		}
		if(repetido){
			lista.borrar(i);
		}
	}
}

/*
@Efecto: 
@Requiere: Una lista no vacia y de tamano minimo de dos
@Modifica: Este metodo modifica la lista
*/
bool subLista(ListaInd& lista1, ListaInd& lista2) {
	int indiceL1 = 0;
	int indiceL2 = 0;
	int indiceL2aux = 0;
	bool esSubLista = false;
	while (!esSubLista && indiceL2 < lista2.numElem()) {
		int cont = 0;
		indiceL2aux = indiceL2;
		while (!esSubLista && indiceL1 < lista1.numElem() && indiceL2aux < lista2.numElem() && lista1.recuperar(indiceL1) == lista2.recuperar(indiceL2aux)) {
			++cont;
			if (cont == lista1.numElem()) {
				esSubLista = true;
			}
			++indiceL1;
			++indiceL2aux;
		}
		indiceL1 = 0;
		if (lista1.recuperar(indiceL1) != lista2.recuperar(indiceL2)) {
			++indiceL2;
		}
	}
	return esSubLista;
}


/*
@Efectua: Busca en la lista el elemento recibido como parametro y devuelve si existe o no
@Requiere: Una lista no vacia y un elemento valido(de tipo) en la lista
@Modifica: Este metodo no modifica nada
*/
bool buscar(ListaInd& lista, int elemento){
	bool existe = false;
	int actual = 0;
	while (!existe && actual < lista.numElem()){
		if( lista.recuperar(actual) == elemento ){
			existe = true;
		}
		++actual;
	}
	return existe;
}



/*
@Efectua:Deja en L3 el resultado de la intersección de L1 y L2.
@Requiere: L1 y L2 sean listas ordenadas y sin elementos repetidos, L3 inicializada y vacía.
@Modifica: Modifica L3
*/
void interseccionOrdenadasV1(ListaInd& l1, ListaInd& l2, ListaInd& l3){
  int actual1 = 0;
  int elem1 = l1.recuperar(actual1);
  int actual2 = 0;
  int elem2 = l2.recuperar(actual2);
  // Se usan las variables elem1 y elem2 con el fin de no hacer muchos llamados al metodo recuperar(int)
  int actual3 = 0;
  int numElemL1= l1.numElem();
  int numElemL2= l2.numElem();
  bool end = false;
  int cantElementosR1 = 0; // Me indica si la cantidad de elemetnos recorridos en l1
  int cantElementosR2 = 0;
  while (!end) {
    if(elem1 == elem2){
      l3.insertar(elem1,actual3++);
      elem1 = l1.recuperar(++actual1);
      elem2 = l2.recuperar(++actual2);
      ++cantElementosR1;
      ++cantElementosR2;
    }
    else{
      if (elem1>elem2){
        elem2 = l2.recuperar(++actual2);
        ++cantElementosR2;
      }
      else{
          elem1 = l1.recuperar(++actual1);
          ++cantElementosR1;
      }
    }
    if(cantElementosR1 == numElemL1 || cantElementosR2 == numElemL2 ){
      end = true;
    }
  }
  }

/*
@Efectua: Deja en L3 el resultado de la intersección de L1 y L2(emplea un algoritmo de busqueda auxiliar).
@Requiere:Requiere que L1 y L2 estén inicializadas y sean listas ordenadas y sin elementos repetidos.
L3 inicializada y sin elementos
@Modifica: Modifica la L3
*/

void interseccionOrdenadasV2(ListaInd& l1, ListaInd& l2, ListaInd& l3){
  int elem1;// Se usa la variable elem1 con el fin de no hacer muchos llamados al metodo recuperar(int)
  int numElemL1= l1.numElem();
  int actual3= 0;
  for(int actual1= 0; actual1 <= numElemL1; ++actual1){
    elem1 = l1.recuperar(actual1);
    if(buscar(l2,elem1)){
      l3.insertar(elem1,actual3++);
    }
  }
}

/*
@Efectua: Deja en L3 el resultado de la intersección de L1 y L2(Supone que L1 y L2 son
listas NO necesariamente ordenadas).
@Requiere:L1 y L2 no tengan elementos repetidos y estén inicializdas.
@Modifica: Modifica L3
*/
void interseccionNoOrdenadas(ListaInd& l1, ListaInd& l2, ListaInd& l3){
  int elem1;
  // Se usa la variable elem1 con el fin de no hacer muchos llamados al metodo recuperar(int)
  int numElemL1= l1.numElem();
  int numElemL2= l2.numElem();
  int actual3= 0;
  bool encontrada;
  for(int actual1= 0; actual1 < numElemL1; ++actual1){
    elem1 = l1.recuperar(actual1);
    encontrada = false;
    for(int actual2 = 0;actual2 < numElemL2 && !encontrada;++actual2 ){
      if(elem1 == l2.recuperar(actual2)){
        l3.insertar(elem1,actual3++);
        encontrada = true;
      }
    }
  }
}


/*
@Efectua:Le agrega a L1 los elementos que están en L2, de manera que en L1 no
queden elementos repetidos(Supone que L1 y L2 son listas NO necesariamente ordenadas).
@Requiere:L1 y L2 inicializadas y que no tengan elementos repetidos.
@Modifica: Modifica L1
*/
void unionNoOrdenadas(ListaInd& l1, ListaInd& l2){
  int elem2;
  // Se usa la variable elem1 con el fin de no hacer muchos llamados al metodo recuperar(int)
  int numElemL1= l1.numElem();
  int numElemL2= l2.numElem();
  bool encontrada;
  int posElemInsercion;
  for(int actual2= 0; actual2 < numElemL2; ++actual2){
    elem2 = l2.recuperar(actual2);
    encontrada = false;
    for(int actual1 = 0; actual1 < numElemL1 && !encontrada;++actual1 ){
      if(elem2 == l1.recuperar(actual1)){
        encontrada = true;
      }
    }
    if (!encontrada) {
      l1.insertar(elem2,l1.numElem());
    }
  }
}


/*
@Efectua:le agrega a L1 los elementos que están en L2, de manera que en L1 no
queden elementos repetidos.
@Requiere: L1 y L2 inicializadas y que sean listas ordenadas y sin elementos repetidos.
@Modifica:Modifica l1
*/
void unionOrdenadas(ListaInd& l1, ListaInd& l2){
  int actual1 = 0;
  int elem1 = l1.recuperar(actual1);
  int actual2 = 0;
  int elem2 = l2.recuperar(actual2);
  // Se usan las variables elem1 y elem2 con el fin de no hacer muchos llamados al metodo recuperar(int)
  int numElemL1= l1.numElem();
  int numElemL2= l2.numElem();
  bool end = false;
  int cantElementosR1 = 1; // Me indica la cantidad de elementos recorridos en l1
  int cantElementosR2 = 1; // Me indica la cantidad de elementos recorridos en l2
  while (!end) {
    if(elem1 == elem2){
		if(cantElementosR1 < numElemL1){
			elem1 = l1.recuperar(++actual1);
		}
            
		if(cantElementosR2 < numElemL2){
			elem2 = l2.recuperar(++actual2);
		}
		if(elem2>elem1 && elem1 == l1.recuperar(l1.numElem()-1)){
			actual1 = l1.numElem();
			l1.insertar(elem2, actual1);
		}
      ++cantElementosR1;
      ++cantElementosR2;
    }
    else{
      if (elem1>elem2){
        l1.insertar(elem2,actual1);
		l1.imprimir();
        ++actual1;
		//++cantElementosR1;
		if(cantElementosR2 < numElemL2){
			elem2 = l2.recuperar(++actual2);
		}
        ++cantElementosR2;
      }
      else{
		if(cantElementosR1 < numElemL1){
			elem1 = l1.recuperar(++actual1);
		}
		else{
			elem1 = l1.recuperar(l1.numElem() - 1);
			actual1 = l1.numElem();
		}
        ++cantElementosR1;
      }
    }
    if(cantElementosR1 >= numElemL1 && cantElementosR2 >= numElemL2 ){
      end = true;
    }
  }
  }


int encuentraPivoteAho(ListaInd& l1, int inicial, int final) {
	int pivoteTemp1 = l1.recuperar(inicial);
	int indicePivote = -1;
	bool pivoteEncontrado = false;
	int contador = inicial;
	cout << "Pivote\n";
	l1.imprimir();
	while (contador <= final && !pivoteEncontrado) {
		if (pivoteTemp1 > l1.recuperar(contador)) {
			pivoteEncontrado = true;
			indicePivote = inicial;
		}
		else if (pivoteTemp1 < l1.recuperar(contador)) {
			pivoteEncontrado = true;
			indicePivote = contador;
		}
		++contador;
	}
	return indicePivote;
}


int parteYOrdena(ListaInd& l1, int inicial, int final) {
	int pivote = l1.recuperar(encuentraPivoteAho(l1, inicial, final));
	int inicioEMP = -1; // Guarda el indice donde inician los elemento mayores que el pivote
	while (inicial < final) {
		cout << "intercambiar\n\n";
		l1.intercambiar(inicial, final);
		while (l1.recuperar(inicial) < pivote) {
			++inicial;
			inicioEMP = inicial;
		}
		while (l1.recuperar(final) >= pivote) {
			--final;
		}
	}
	return inicioEMP;
}

void quickSort(ListaInd& l1, int inicial, int final){
	if (inicial!=final && inicial < final && encuentraPivoteAho(l1,inicial,final)!= -1){
		int indiceDivisor = parteYOrdena(l1, inicial, final);
		quickSort(l1, inicial, indiceDivisor-1);
		quickSort(l1,indiceDivisor,final);
	}
}
