#include "ListaPosicionada_Arreglo.h"
ListaPos::posicion traducir(ListaPos& lista, int indice) { //Traduce un indice ingresado por el usuarion en una posicion
	ListaPos::posicion pos;
	pos = lista.getPrimera();
	for (int i = 1; i < indice; ++i)
		pos = lista.siguiente(pos);
	return pos;
}

bool buscar(ListaPos& lista, int elemento){
	bool existe = false;
	int cont = 0;
	ListaPos::posicion pos = lista.getPrimera();
	while (!existe && cont < lista.numElem()){ //pos?
		if( lista.recuperar(pos) == elemento ){
			existe = true;
		}
		pos = lista.siguiente(pos);
	}
	return existe;
}

void invertir(ListaPos& lista){
	ListaPos::posicion posI = lista.getPrimera();
	ListaPos::posicion posF = lista.getUltima();
	while(posI != posF && lista.siguiente(posI) != posF){ //probar lista.recuperar(posI) != lista.recuperar(posF) && lista.recuperar(lista.siguiente(posI)) != lista.recuperar(posF)
		lista.intercambiar(posI,posF);
		posI = lista.siguiente(posI);
		posF = lista.anterior(posF);
	}
	lista.intercambiar(posI,posF);
}

bool simetrica(ListaPos& lista){
	ListaPos::posicion posI = lista.getPrimera();
	ListaPos::posicion posF = lista.getUltima();
	bool esSimetrica = true;
	while(esSimetrica && posI != posF && lista.siguiente(posI) != posF) { //probar
		if(lista.recuperar(posI) != lista.recuperar(posF)){
			esSimetrica = false;
		}
		posI = lista.siguiente(posI);
		posF = lista.anterior(posF);
	}
	if (lista.recuperar(posI) != lista.recuperar(posF)) {
		esSimetrica = false;
	}
	return esSimetrica;
}

void seleccionIterativo(ListaPos& lista){
	ListaPos::posicion posMin;
	ListaPos::posicion posI = lista.getPrimera();																																												
	for(int i = 0; i < lista.numElem() -1 ; ++i){
		ListaPos::posicion posJ = lista.siguiente(posI);
		posMin = posI;
		for(int j = i+1 ; j < lista.numElem(); ++j){
			if(lista.recuperar(posJ) < lista.recuperar(posMin)){
				posMin = posJ;
			} 
			posJ = lista.siguiente(posJ);
		}
		lista.intercambiar(posI,posMin);
		posI = lista.siguiente(posI);
	}
}

void seleccionRecursivo(ListaPos& lista, int inicio) {
	if (inicio == lista.numElem() -1) {
		return;
	}
	else {
		ListaPos::posicion posI = traducir(lista, inicio);
		ListaPos::posicion minimo = posI;
		ListaPos::posicion posActual = posI;
		posI = lista.siguiente(posI);
		for (int i = inicio + 1; i <= lista.numElem(); ++i) {
			if (lista.recuperar(posI) < lista.recuperar(minimo)) {
				minimo = posI;
			}
			posI = lista.siguiente(posI);
		}
		lista.intercambiar(posActual, minimo);
		seleccionRecursivo(lista, ++inicio);
	}
}


void burbujaOriginal(ListaPos& lista) { //revisar
	ListaPos::posicion posI = lista.getPrimera();
	ListaPos::posicion posJ;
	for (int i = 0; i < lista.numElem() - 1; ++i) {
		posJ = lista.getPrimera();
		for (int j = 0; j < lista.numElem() - i - 1; ++j) { //solucionar error
			if (lista.recuperar(posJ) > lista.recuperar(lista.siguiente(posJ)) ) {
				lista.intercambiar(lista.siguiente(posJ) , posJ);
			}
			posJ = lista.siguiente(posJ);
		}
		posI = lista.siguiente(posI);
	}
}

void eliminarRepetidos(ListaPos& lista){
	ListaPos::posicion posI = lista.getPrimera();
	ListaPos::posicion posJ = posI;
	for(int i = 0; i < lista.numElem(); ++i){
		bool repetido = false;
		for(int j = 0; j < lista.numElem(); ++j){
			if(i != j && lista.recuperar(posI) == lista.recuperar(posJ) ){
				repetido = true;
				j = lista.numElem();
			}
			posJ = lista.siguiente(posJ);
		}
		if(repetido){
			lista.borrar(posI);
		}
		posI = lista.siguiente(posI);
	}
}
