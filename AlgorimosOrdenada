@Efecto: Inserta todos los datos de la lista original en la nueva con el fin de que queden exactamente iguales
@Requiere: Una lista original no vacia y una lista nueva sin elementos
@Modifica: La lista nueva
*/
void copiar(ListaOrdenada& listaOriginal, ListaOrdenada& listaNueva) {
	int actual = listaOriginal.primero();
	int cont = 1;
	while (cont <= listaOriginal.numElem()) {
		listaNueva.insertar(actual);
		actual = listaOriginal.siguiente(actual);
		cont++;
	}
}


/*
@Efecto: Indica si el elemento pertenece a la Lista Ordenada
@Requiere: Una lista no vacia
@Modifica: Este metodo no modifica nada
*/
bool pertenece(ListaOrdenada& lista, int elemento) {
	bool pertenece = false;
	int actual = lista.primero();
	int cont = 0;
	while (cont <= lista.numElem() && !pertenece){
		if (elemento == actual) {
			pertenece = true;
		}
		actual = lista.siguiente(actual);
	}
	return pertenece;
}

/*
@Efecto: Encuentra la union entre dos listas y la deja en una lista nueva
@Requiere: Dos listas no vacias
@Modifica: Este metodo modifica la nueva lista
*/
void unionListas(ListaOrdenada& lista1, ListaOrdenada& lista2, ListaOrdenada& listaUnion) {
	int actualL1 = lista1.primero();
	int contador = 1;
	int actualL2 = lista2.primero();
	
	while (contador <= lista1.numElem() && contador <= lista2.numElem()){
		listaUnion.insertar(actualL1);
		listaUnion.insertar(actualL2);
		actualL1 = lista1.siguiente(actualL1);
		actualL2 = lista2.siguiente(actualL2);
		++contador;
	}
	while(contador <= lista1.numElem()){
		listaUnion.insertar(actualL1);
		actualL1 = lista1.siguiente(actualL1);
		++contador;
	}
	
	while(contador <= lista2.numElem()){
		listaUnion.insertar(actualL2);
		actualL2 = lista2.siguiente(actualL2);
		++contador;
	} 
	
}



//Efecto: Averigua si L1 es igual a L2, y retorna un booleano true si son iguales, false si no lo son.
//Requiere: L1 , L2 inicializadas
//Modifica: No modifica las listas
bool iguales(ListaOrdenada& l1, ListaOrdenada& l2){
  bool iguales = true;
  int actual1 = l1.primero();
  int actual2 = l2.primero();
  int cantElementos = 0;
  if(l1.numElem()!=l2.numElem()){
    iguales = false;
    cantElementos = l1.numElem();
  }
  int contador = 1;
  while(iguales && contador<= cantElementos){
    if(actual1 != actual2){
      iguales = false;
    }
    else{
      actual1 = l1.siguiente(actual1);
      actual2 = l2.siguiente(actual2);
      ++contador;
    }
  }
  return iguales;
}


//Efecto: Revisa si la lista listaPorVerificar est치 contenida en listaPrincipal, retorna un booleano true si est치 contenida, false si no
//Requiere: listaPorVerificar  y listaPrincipal inicializadas
//Modifica: No modifica las listas
bool contenida(ListaOrdenada& listaPorVerificar, ListaOrdenada& listaPrincipal){
  bool contenida = false;
  if(listaPrincipal.numElem() >= listaPorVerificar.numElem()){
    int actual1 = listaPorVerificar.primero();
    int actual2 = listaPrincipal.primero();
    int cantElementosLPorVerificar= listaPorVerificar.numElem();
    int elemContenidos = 0;
    int cantElementosLPrincipal = listaPrincipal.numElem();
    for (int i = 1; i <= cantElementosLPrincipal && elemContenidos!=cantElementosLPorVerificar ; ++i) {
      if(actual1 == actual2){
         ++elemContenidos;
         actual1 = listaPorVerificar.siguiente(actual1);
         actual2 = listaPrincipal.siguiente(actual2);
       }
       else{
         actual2 = listaPrincipal.siguiente(actual2);
       }
    }
    if(elemContenidos == cantElementosLPorVerificar){
      contenida = true;
      }
    }
   return contenida;
  }

//Efecto:Eliminar de l1 los elementos que est치n en l2
//Requiere:l1,l2 inicializadas
//Modifica: Modifica la lista l1
void borrarComunes(ListaOrdenada& l1, ListaOrdenada& l2){
int actual1 = l1.primero();
int actual2 = l2.primero();
int numElemL1= l1.numElem();
int victima;
cout<<"numElemL1:"<<numElemL1<<endl;
bool end = false;
int cantElementosR1 = 0;
while (!end) {
  if(actual1 == actual2){
    victima = actual1;
    actual1 = l1.siguiente(actual1);
    actual2 = l2.siguiente(actual2);
    l1.borrar(victima);
    ++cantElementosR1;
    cout<<"cantElementosR1:"<<cantElementosR1<<endl;
  }
  else{
    if (actual1>actual2){
      actual2 = l2.siguiente(actual2);
    }
    else{
        actual1 = l1.siguiente(actual1);
        ++cantElementosR1;
    }
  }
  if(cantElementosR1 == numElemL1){
    end = true;
  }
}
}

//Efecto:Deja en L3 el resultado de la intersecci칩n de L1 y L2
//Requiere:l1,l2,l3 inicializadas
//Modifica: Modifica la lista l3
void interseccion(ListaOrdenada& l1, ListaOrdenada& l2, ListaOrdenada& l3){
  int actual1 = l1.primero();
  int actual2 = l2.primero();
  int numElemL1= l1.numElem();
  int numElemL2= l2.numElem();
  bool end = false;
  int cantElementosR1 = 0;
  int cantElementosR2 = 0;
  while (!end) {
    if(actual1 == actual2){
      l3.insertar(actual1);
      actual1 = l1.siguiente(actual1);
      actual2 = l2.siguiente(actual2);
      ++cantElementosR1;
    }
    else{
      if (actual1>actual2){
        actual2 = l2.siguiente(actual2);
      }
      else{
          actual1 = l1.siguiente(actual1);
          ++cantElementosR1;
      }
    }
    if(cantElementosR1 == numElemL1 || cantElementosR2 == numElemL2){
      end = true;
    }
  }
  }

